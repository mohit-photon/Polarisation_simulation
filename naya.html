<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Light Polarization Simulator </title>
    <style>
        *{box-sizing:border-box;margin:0;padding:0;}
        body{
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg,#0a0a0a,#1a1a2e);
            color:#fff; min-height:100vh; overflow-x:auto;
        }
        .container{max-width:1400px;margin:0 auto;padding:20px;}
        h1{
            text-align:center;font-size:2.2rem;margin-bottom:20px;
            background:linear-gradient(45deg,#ff6b6b,#4ecdc4);
            -webkit-background-clip:text;-webkit-text-fill-color:transparent;
        }
        .main-content{display:grid;grid-template-columns:1fr 420px;gap:20px;margin-bottom:30px;}
        .simulation-area{
            background:rgba(255,255,255,0.04);border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.06);
            backdrop-filter:blur(8px);
        }
        .controls-panel{background:rgba(255,255,255,0.06);border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.06);}
        .optical-path{display:flex;align-items:center;justify-content:space-between;min-height:110px;padding:14px;border-radius:10px;background:linear-gradient(90deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));position:relative;overflow:hidden;margin-bottom:12px;}
        .light-beam{position:absolute;top:50%;left:0;right:0;height:4px;background:linear-gradient(90deg, rgba(255,255,0,0.8), rgba(255,200,0,0.6), rgba(255,150,0,0.4));transform:translateY(-50%);border-radius:2px;}
        .light-source{width:56px;height:56px;border-radius:50%;background:radial-gradient(circle,#ffff00,#ff9900);display:flex;align-items:center;justify-content:center;font-weight:bold;color:#000;box-shadow:0 0 20px rgba(255,255,0,0.5);z-index:10;}
        .polarizer{width:76px;height:96px;background:rgba(100,100,255,0.28);border:2px solid #4ecdc4;border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:12px;text-align:center;position:relative;padding:6px;margin:0 6px;}
        .polarizer.qwp{background:rgba(255,100,100,0.28);border-color:#ff6b6b;}
        .polarizer.hwp{background:rgba(100,255,200,0.12);border-color:#4ecdc4;}
        .output-detector{width:76px;height:76px;background:linear-gradient(45deg,#4ecdc4,#44a08d);border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:14px;box-shadow:0 0 15px rgba(78,205,196,0.5);z-index:10;}
        .canvas-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:14px;margin-top:12px;}
        /* we'll show 4 canvases in two rows */
        .canvas-grid-extended{display:grid;grid-template-columns:repeat(2,1fr);gap:14px;margin-top:12px;}
        canvas.wave-canvas{width:100%;height:200px;border-radius:10px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.28);display:block;}
        .controls-section{margin-bottom:18px;}
        .controls-section h3{color:#4ecdc4;margin-bottom:10px;font-size:1.05rem;}
        .control-group{margin-bottom:10px;}
        label{display:block;margin-bottom:6px;color:#ccc;font-size:14px;}
        .slider{width:100%;height:6px;border-radius:4px;background:rgba(255,255,255,0.12);outline:none;}
        .slider::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:#4ecdc4;cursor:pointer;box-shadow:0 0 10px rgba(78,205,196,0.5);}
        .btn{padding:9px 14px;border-radius:8px;border:0;cursor:pointer;margin:6px 6px 0 0;}
        .btn-add{background:linear-gradient(45deg,#4ecdc4,#44a08d);color:#fff;}
        .btn-remove{background:linear-gradient(45deg,#ff6b6b,#ee5a52);color:#fff;}
        .info-panel{background:rgba(255,255,255,0.04);border-radius:8px;padding:10px;margin-top:10px;border:1px solid rgba(255,255,255,0.06);}
        .jones-vector{background:rgba(0,0,0,0.3);padding:8px;border-radius:6px;margin:8px 0;border-left:3px solid #4ecdc4;font-family:monospace;}
        .polarizer-list{margin-top:12px;}
        .polarizer-list .item{background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;margin-bottom:8px;display:flex;align-items:center;gap:8px;}
        .polarizer-list .item .meta{flex:1;}
        .angle-display{font-size:12px;color:#ddd;margin-top:6px;}
        @media(max-width:980px){ .main-content{grid-template-columns:1fr;} .canvas-grid{grid-template-columns:1fr;} }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive Light Polarization Simulator — Extended</h1>

        <div class="main-content">
            <div class="simulation-area">
                <div class="optical-path" id="opticalPath">
                    <div class="light-beam"></div>
                    <div class="light-source">SRC</div>
                    <div class="output-detector" id="detector">OUT</div>
                </div>

                <!-- Canvases: Input (unpolarized animated), Output X, Output Y, Polarized Output -->
                <div class="canvas-grid-extended">
                    <div>
                        <h4 style="text-align:center;color:#4ecdc4;margin-bottom:8px;">Input — Unpolarized (animated)</h4>
                        <canvas id="inputCanvas" class="wave-canvas"></canvas>
                    </div>
                    <div>
                        <h4 style="text-align:center;color:#4ecdc4;margin-bottom:8px;">Polarized Output (ellipse)</h4>
                        <canvas id="polarizedCanvas" class="wave-canvas"></canvas>
                    </div>
                    <div>
                        <h4 style="text-align:center;color:#4ecdc4;margin-bottom:8px;">Output — X component</h4>
                        <canvas id="outputXCanvas" class="wave-canvas"></canvas>
                    </div>
                    <div>
                        <h4 style="text-align:center;color:#4ecdc4;margin-bottom:8px;">Output — Y component</h4>
                        <canvas id="outputYCanvas" class="wave-canvas"></canvas>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Polarization Analysis</h4>
                    <div id="polarizationInfo" class="polarization-state">
                        <div>Input: Unpolarized Light</div>
                        <div>Output: <span id="outputState">Unpolarized</span></div>
                        <div class="jones-vector" id="jonesVector">
                            Jones Vector: [1, 0]
                        </div>
                        <div>Intensity: <span id="intensityValue">100%</span></div>
                        <div class="intensity-bar" style="height:12px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;margin-top:8px;">
                            <div class="intensity-fill" id="intensityBar" style="width:100%;height:100%;background:linear-gradient(90deg,#4ecdc4,#44a08d)"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="controls-section">
                    <h3>Add Polarizers</h3>
                    <div class="control-group">
                        <label>Polarizer Type:</label>
                        <select id="polarizerType">
                            <option value="linear">Linear Polarizer</option>
                            <option value="qwp">Quarter Wave Plate</option>
                            <option value="hwp">Half Wave Plate</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Angle (degrees): <span id="angleValue">0</span></label>
                        <input type="range" id="angleSlider" class="slider" min="0" max="180" value="0">
                    </div>
                    <div>
                        <button class="btn btn-add" onclick="addPolarizer()">Add Polarizer</button>
                        <button class="btn btn-remove" onclick="clearAll()">Clear All</button>
                    </div>

                    <!-- per-polarizer control list -->
                    <div id="polarizerList" class="polarizer-list"></div>
                </div>

                <div class="controls-section">
                    <h3>Animation Control</h3>
                    <div class="control-group">
                        <label>Wave Speed: <span id="speedValue">1.0</span></label>
                        <input type="range" id="speedSlider" class="slider" min="0.1" max="3.0" step="0.1" value="1.0">
                    </div>
                    <div class="control-group">
                        <label>Amplitude Scale: <span id="amplitudeValue">1.0</span></label>
                        <input type="range" id="amplitudeSlider" class="slider" min="0.1" max="2.0" step="0.1" value="1.0">
                    </div>
                </div>

                <div class="controls-section">
                    <h3>Jones Calculus</h3>
                    <div style="font-size:12px;line-height:1.4;">
                        <div>Linear Polarizer (θ):<br>[cos²θ &nbsp; cosθ sinθ]<br>[cosθ sinθ &nbsp; sin²θ]</div><br>
                        <div>Quarter Wave Plate:<br>[1 &nbsp; 0]<br>[0 &nbsp; i]</div><br>
                        <div>Half Wave Plate:<br>[1 &nbsp; 0]<br>[0 &nbsp; -1]</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
/* -------------------------
   Complex, JonesVector, JonesMatrix
   (kept from your previous code with same API)
   ------------------------- */
class Complex {
    constructor(real, imag = 0) { this.real = real; this.imag = imag; }
    multiply(other) {
        if (typeof other === 'number') return new Complex(this.real * other, this.imag * other);
        return new Complex(this.real * other.real - this.imag * other.imag, this.real * other.imag + this.imag * other.real);
    }
    add(other) { return new Complex(this.real + other.real, this.imag + other.imag); }
    magnitude() { return Math.sqrt(this.real * this.real + this.imag * this.imag); }
    phase() { return Math.atan2(this.imag, this.real); }
    toString() {
        if (this.imag === 0) return this.real.toFixed(3);
        if (this.real === 0) return `${this.imag.toFixed(3)}i`;
        return `${this.real.toFixed(3)} ${this.imag >= 0 ? '+' : ''}${this.imag.toFixed(3)}i`;
    }
}

class JonesVector {
    constructor(ex, ey) {
        this.ex = ex instanceof Complex ? ex : new Complex(ex);
        this.ey = ey instanceof Complex ? ey : new Complex(ey);
    }
    intensity() { return this.ex.magnitude() ** 2 + this.ey.magnitude() ** 2; }
    normalize() {
        const I = this.intensity(); if (I === 0) return new JonesVector(new Complex(0), new Complex(0));
        const n = Math.sqrt(I); return new JonesVector(new Complex(this.ex.real / n, this.ex.imag / n), new Complex(this.ey.real / n, this.ey.imag / n));
    }
    getPolarizationType() {
        const ex_mag = this.ex.magnitude(), ey_mag = this.ey.magnitude();
        if (ex_mag === 0 && ey_mag === 0) return "No light";
        if (ey_mag === 0) return "Linear (horizontal)";
        if (ex_mag === 0) return "Linear (vertical)";
        const phase_diff = (this.ey.phase() - this.ex.phase());
        const ratio = ey_mag / ex_mag;
        const phase_norm = ((phase_diff % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        if (Math.abs(phase_norm) < 0.1 || Math.abs(phase_norm - 2 * Math.PI) < 0.1) return "Linear";
        if (Math.abs(phase_norm - Math.PI) < 0.1) return "Linear";
        if (Math.abs(ratio - 1) < 0.1 && (Math.abs(phase_norm - Math.PI/2) < 0.15 || Math.abs(phase_norm - 3*Math.PI/2) < 0.15)) return phase_norm < Math.PI ? "Right Circular" : "Left Circular";
        return "Elliptical";
    }
}

class JonesMatrix {
    constructor(m11, m12, m21, m22) {
        this.m11 = m11 instanceof Complex ? m11 : new Complex(m11);
        this.m12 = m12 instanceof Complex ? m12 : new Complex(m12);
        this.m21 = m21 instanceof Complex ? m21 : new Complex(m21);
        this.m22 = m22 instanceof Complex ? m22 : new Complex(m22);
    }
    multiply(vector) {
        if (vector instanceof JonesVector) {
            return new JonesVector(
                this.m11.multiply(vector.ex).add(this.m12.multiply(vector.ey)),
                this.m21.multiply(vector.ex).add(this.m22.multiply(vector.ey))
            );
        } else if (vector instanceof JonesMatrix) {
            return new JonesMatrix(
                this.m11.multiply(vector.m11).add(this.m12.multiply(vector.m21)),
                this.m11.multiply(vector.m12).add(this.m12.multiply(vector.m22)),
                this.m21.multiply(vector.m11).add(this.m22.multiply(vector.m21)),
                this.m21.multiply(vector.m12).add(this.m22.multiply(vector.m22))
            );
        }
    }
    static linearPolarizer(angle) {
        const th = angle * Math.PI/180;
        const c = Math.cos(th), s = Math.sin(th);
        return new JonesMatrix(c*c, c*s, c*s, s*s);
    }
    static quarterWavePlate(angle = 0) {
        const th = angle * Math.PI/180;
        // exact rotated QWP = R(-θ) * diag(1, i) * R(θ)
        // we'll compute exactly here for better accuracy
        const R = (a) => [[Math.cos(a), -Math.sin(a)],[Math.sin(a), Math.cos(a)]];
        const a = th, Ra = R(a), Rma = R(-a);
        // diag(1, i)
        const iC = new Complex(0,1);
        // build matrices in complex form
        // Rma * D * Ra
        // compute intermediate complex 2x2
        const D = [[new Complex(1,0), new Complex(0,0)],[new Complex(0,0), iC]];
        // convert Ra & Rma to Complex entries
        const RaC = [[new Complex(Ra[0][0],0), new Complex(Ra[0][1],0)],[new Complex(Ra[1][0],0), new Complex(Ra[1][1],0)]];
        const RmaC = [[new Complex(Rma[0][0],0), new Complex(Rma[0][1],0)],[new Complex(Rma[1][0],0), new Complex(Rma[1][1],0)]];
        // multiply RmaC * D * RaC
        const mul = (A,B) => {
            return [
                [ A[0][0].multiply(B[0][0]).add(A[0][1].multiply(B[1][0])), A[0][0].multiply(B[0][1]).add(A[0][1].multiply(B[1][1])) ],
                [ A[1][0].multiply(B[0][0]).add(A[1][1].multiply(B[1][0])), A[1][0].multiply(B[0][1]).add(A[1][1].multiply(B[1][1])) ]
            ];
        };
        const Mtemp = mul(D, RaC);
        const M = mul(RmaC, Mtemp);
        return new JonesMatrix(M[0][0], M[0][1], M[1][0], M[1][1]);
    }
    static halfWavePlate(angle = 0) {
        const th = angle * Math.PI/180;
        // exact rotated HWP = R(-θ) * diag(1, -1) * R(θ)
        const c2 = Math.cos(2*th), s2 = Math.sin(2*th);
        return new JonesMatrix(c2, s2, s2, -c2);
    }
}

/* -------------------------
   state + DOM refs
   ------------------------- */
let polarizers = [];
let time = 0;
let waveSpeed = 1.0;
let amplitudeScale = 1.0;

// canvases
const inputCanvas = document.getElementById('inputCanvas');
const polarizedCanvas = document.getElementById('polarizedCanvas');
const outputXCanvas = document.getElementById('outputXCanvas');
const outputYCanvas = document.getElementById('outputYCanvas');

[inputCanvas, polarizedCanvas, outputXCanvas, outputYCanvas].forEach(c=>{
    // set logical drawing size (for crispness)
    const w = c.clientWidth || 300;
    c.width = Math.max(320, Math.floor(c.clientWidth*devicePixelRatio));
    c.height = Math.max(200, Math.floor(c.clientHeight*devicePixelRatio));
});

const inputCtx = inputCanvas.getContext('2d');
const polarizedCtx = polarizedCanvas.getContext('2d');
const outXCtx = outputXCanvas.getContext('2d');
const outYCtx = outputYCanvas.getContext('2d');

/* -------------------------
   Unpolarized input particles
   ------------------------- */
const particles = [];
const NPART = 60;
function initParticles() {
    particles.length = 0;
    const rect = inputCanvas.getBoundingClientRect();
    const W = inputCanvas.width;
    const H = inputCanvas.height;
    for (let i=0;i<NPART;i++){
        const angle = Math.random()*Math.PI*2;
        const speed = 0.3 + Math.random()*1.2;
        particles.push({
            x: Math.random()*W,
            y: Math.random()*H,
            vx: Math.cos(angle)*speed,
            vy: Math.sin(angle)*speed,
            orient: angle,
            len: 8 + Math.random()*14,
            color: (Math.random()<0.5) ? '#ffff66' : '#ffd24d',
            opacity: 0.25 + Math.random()*0.6
        });
    }
}
initParticles();

/* -------------------------
   Event handlers
   ------------------------- */
document.getElementById('angleSlider').addEventListener('input', function(e){
    document.getElementById('angleValue').textContent = e.target.value;
});
document.getElementById('speedSlider').addEventListener('input', function(e){
    waveSpeed = parseFloat(e.target.value);
    document.getElementById('speedValue').textContent = waveSpeed.toFixed(1);
});
document.getElementById('amplitudeSlider').addEventListener('input', function(e){
    amplitudeScale = parseFloat(e.target.value);
    document.getElementById('amplitudeValue').textContent = amplitudeScale.toFixed(1);
});

/* -------------------------
   Add / remove / clear / UI
   ------------------------- */
function addPolarizer(){
    const type = document.getElementById('polarizerType').value;
    const angle = parseInt(document.getElementById('angleSlider').value);
    const pol = { id: Date.now() + Math.floor(Math.random()*1000), type, angle };
    polarizers.push(pol);
    updateOpticalPath();
    renderPolarizerControls();
    // recalc
    updateSimulation();
}
function removePolarizer(id){
    polarizers = polarizers.filter(p=>p.id!==id);
    updateOpticalPath();
    renderPolarizerControls();
    updateSimulation();
}
function clearAll(){
    polarizers = [];
    updateOpticalPath();
    renderPolarizerControls();
    updateSimulation();
}

/* update optical path visuals (adds DOM polarizer blocks) */
function updateOpticalPath(){
    const path = document.getElementById('opticalPath');
    const detector = path.querySelector('#detector');
    // remove existing polarizers
    path.querySelectorAll('.polarizer').forEach(n=>n.remove());
    // insert all polarizers before detector
    for (const pol of polarizers){
        const el = document.createElement('div');
        el.className = `polarizer ${pol.type==='qwp'?'qwp':pol.type==='hwp'?'hwp':''}`;
        el.dataset.id = pol.id;
        el.innerHTML = `<div style="font-weight:700;">${pol.type.toUpperCase()}</div><div class="angle-display">${pol.angle}°</div>
            <button class="remove-btn" onclick="removePolarizer(${pol.id})">×</button>`;
        path.insertBefore(el, detector);
    }
}

/* per-polarizer controls in the right panel */
function renderPolarizerControls(){
    const list = document.getElementById('polarizerList');
    list.innerHTML = '';
    for (const pol of polarizers){
        const item = document.createElement('div');
        item.className = 'item';
        item.innerHTML = `<div class="meta"><div style="font-weight:600">${pol.type.toUpperCase()} <span style="font-weight:400;font-size:12px;">#${pol.id}</span></div>
            <div style="display:flex;align-items:center;gap:8px;margin-top:6px;">
                <input type="range" min="0" max="180" value="${pol.angle}" data-id="${pol.id}" class="polar-angle-slider" style="flex:1" />
                <div id="angleLabel-${pol.id}" style="min-width:46px;text-align:right;color:#ddd">${pol.angle}°</div>
            </div></div>
            <div><button data-remove="${pol.id}" style="padding:6px;border-radius:6px;border:0;background:#ff6b6b;color:#fff;cursor:pointer;">Remove</button></div>`;
        list.appendChild(item);
    }

    // wire events
    list.querySelectorAll('.polar-angle-slider').forEach(sl=>{
        sl.addEventListener('input', (ev)=>{
            const id = Number(ev.target.dataset.id);
            const val = Number(ev.target.value);
            const obj = polarizers.find(p=>p.id===id);
            if (!obj) return;
            obj.angle = val;
            const lbl = document.getElementById(`angleLabel-${id}`);
            if (lbl) lbl.textContent = val + '°';
            const visual = document.querySelector(`.polarizer[data-id="${id}"]`);
            if (visual){
                const ad = visual.querySelector('.angle-display');
                if (ad) ad.textContent = val + '°';
            }
            updateSimulation();
        });
    });

    list.querySelectorAll('[data-remove]').forEach(btn=>{
        btn.addEventListener('click', (ev)=>{
            const id = Number(ev.target.dataset.remove);
            removePolarizer(id);
        });
    });
}

/* -------------------------
   Jones stack math & output
   ------------------------- */
function calculateOutput(){
    // Start with horizontal unit amplitude
    let vec = new JonesVector(new Complex(1), new Complex(0));
    for (const pol of polarizers){
        let M;
        if (pol.type === 'linear') M = JonesMatrix.linearPolarizer(pol.angle);
        else if (pol.type === 'qwp') M = JonesMatrix.quarterWavePlate(pol.angle);
        else if (pol.type === 'hwp') M = JonesMatrix.halfWavePlate(pol.angle);
        vec = M.multiply(vec);
    }
    return vec;
}

/* -------------------------
   Drawing helpers
   ------------------------- */

function clearCanvas(ctx){
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    ctx.restore();
}

/* Input: animate unpolarized particles moving randomly */
function drawUnpolarized(ctx, dt){
    // adapt to canvas resolution
    const W = ctx.canvas.width;
    const H = ctx.canvas.height;
    // update particles
    for (const p of particles){
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        // bounce edges
        if (p.x < -20) p.x = W + 20;
        if (p.x > W + 20) p.x = -20;
        if (p.y < -20) p.y = H + 20;
        if (p.y > H + 20) p.y = -20;
        // slowly rotate
        p.orient += (Math.random()-0.5)*0.01;
    }

    clearCanvas(ctx);
    // draw background axes faint
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0,H/2); ctx.lineTo(W,H/2);
    ctx.moveTo(W/2,0); ctx.lineTo(W/2,H);
    ctx.stroke();

    // draw particles (small oriented sticks)
    for (const p of particles){
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.orient);
        ctx.globalAlpha = p.opacity;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-p.len*0.5,0); ctx.lineTo(p.len*0.5,0);
        ctx.stroke();
        ctx.restore();
    }
    // label
    ctx.fillStyle = '#4ecdc4';
    ctx.font = `${12 * devicePixelRatio}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('Unpolarized (many small vectors moving randomly)', W/2, H - 6 * devicePixelRatio);
}

/* Draw single-component wave (x or y) */
function drawComponentWave(ctx, magnitude, phase, color, dt){
    const W = ctx.canvas.width;
    const H = ctx.canvas.height;
    clearCanvas(ctx);
    // axes
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0,H/2); ctx.lineTo(W,H/2);
    ctx.moveTo(W/2,0); ctx.lineTo(W/2,H);
    ctx.stroke();

    const maxAmp = 60 * amplitudeScale * (devicePixelRatio || 1);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let x=0;x<W;x++){
        const t = (x / W) * 4 * Math.PI;
        const y = H/2 + magnitude * maxAmp * Math.sin(t + phase + time * waveSpeed);
        if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // label
    ctx.fillStyle = '#4ecdc4';
    ctx.font = `${12 * (devicePixelRatio||1)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(color === '#ff6b6b' ? 'X component' : 'Y component', W/2, H - 6 * devicePixelRatio);
}

/* Draw polarized output: ellipse + components */
function drawPolarized(ctx, vec, dt){
    const W = ctx.canvas.width, H = ctx.canvas.height;
    clearCanvas(ctx);

    // small axes
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();

    const ex_mag = vec.ex.magnitude(), ey_mag = vec.ey.magnitude();
    const ex_phase = vec.ex.phase(), ey_phase = vec.ey.phase();
    // components as thin waves (overlay)
    const centerX = W/2, centerY = H/2;
    const maxAmp = 50 * amplitudeScale * (devicePixelRatio || 1);

    // draw ellipse by param t
    ctx.beginPath();
    const samples = 200;
    for (let i=0;i<=samples;i++){
        const t = (i / samples) * Math.PI * 2;
        const Ex = ex_mag * Math.cos(t + ex_phase + time*waveSpeed);
        const Ey = ey_mag * Math.cos(t + ey_phase + time*waveSpeed);
        const px = centerX + Ex * maxAmp * 0.6;
        const py = centerY - Ey * maxAmp * 0.6;
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
    ctx.fillStyle = 'rgba(30,144,255,0.06)';
    ctx.fill();
    ctx.strokeStyle = '#1e90ff';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // draw component waveforms (thin)
    ctx.beginPath();
    ctx.strokeStyle = '#ff6b6b';
    for (let x=0;x<W;x++){
        const t = (x / W) * 4 * Math.PI;
        const y = centerY + ex_mag * maxAmp * Math.sin(t + ex_phase + time * waveSpeed) * 0.25;
        if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = '#4ecdc4';
    for (let x=0;x<W;x++){
        const t = (x / W) * 4 * Math.PI;
        const y = centerY + ey_mag * maxAmp * Math.sin(t + ey_phase + time * waveSpeed) * 0.25;
        if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // label and type
    ctx.fillStyle = '#4ecdc4';
    ctx.font = `${12 * (devicePixelRatio||1)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(vec.getPolarizationType(), W/2, H - 6 * devicePixelRatio);
}

/* -------------------------
   Update info panel
   ------------------------- */
function updateSimulation(){
    const outVec = calculateOutput();
    const intensity = outVec.intensity();
    const dispI = Math.min(1, intensity);
    document.getElementById('outputState').textContent = outVec.getPolarizationType();
    document.getElementById('jonesVector').textContent = `Jones Vector: [${outVec.ex.toString()}, ${outVec.ey.toString()}]`;
    document.getElementById('intensityValue').textContent = `${(dispI*100).toFixed(1)}%`;
    document.getElementById('intensityBar').style.width = `${dispI*100}%`;
    // detector color
    const detector = document.getElementById('detector');
    const alpha = Math.max(0.12, dispI);
    detector.style.background = `linear-gradient(45deg, rgba(78,205,196,${alpha}), rgba(68,160,141,${alpha}))`;
}

/* -------------------------
   Animation loop
   ------------------------- */
let last = performance.now();
function animate(now){
    const dt = (now - last) / 16.666; // ~frames ratio, used to scale velocity sensibly
    last = now;
    time += 0.06 * dt;

    // update input (particles)
    drawUnpolarized(inputCtx, dt);

    // compute current output vector
    const outVec = calculateOutput();

    // draw polarized-only output
    drawPolarized(polarizedCtx, outVec, dt);

    // draw X and Y components separately
    drawComponentWave(outXCtx, outVec.ex.magnitude(), outVec.ex.phase(), '#ff6b6b', dt);
    drawComponentWave(outYCtx, outVec.ey.magnitude(), outVec.ey.phase(), '#4ecdc4', dt);

    // next
    requestAnimationFrame(animate);
}

/* -------------------------
   Initialization
   ------------------------- */
updateOpticalPath();
renderPolarizerControls();
updateSimulation();
requestAnimationFrame(animate);

// keep responsive: resize canvases when window size changes
window.addEventListener('resize', ()=>{
    [inputCanvas, polarizedCanvas, outputXCanvas, outputYCanvas].forEach(c=>{
        const rect = c.getBoundingClientRect();
        c.width = Math.max(320, Math.floor(rect.width * devicePixelRatio));
        c.height = Math.max(200, Math.floor(rect.height * devicePixelRatio));
    });
    initParticles();
});
</script>
</body>
</html>
